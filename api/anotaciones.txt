(1°) me conecto a postgres desde la terminal
sudo -u postgres psql

(2°) CREO LA BASE DE DATOS:

CREATE DATABASE nombre_db;

(3°) HAGO LA CONECCION CON SEQUELIZE:

CREO EL ARCHIVO .env sobre mi carpeta raiz "api"

y en...

//db.js

const {
  DB_USER, DB_PASSWORD, DB_HOST, // ESTAS SON LAS VARIABLES DE ENTORNO EN ".env"
} = process.env;

const sequelize = new Sequelize(`postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}/breakingbad`, {
  logging: false, // set to console.log to see the raw SQL queries
  native: false, // lets Sequelize know we can use pg-native for ~30% more speed
});

(4°) CREO LOS MODELOS en la carpeta models

const { DataTypes } = require('sequelize');
// Exportamos una funcion que define el modelo
// Luego le injectamos la conexion a sequelize.
module.exports = (sequelize) => {
  // defino el modelo
  sequelize.define('occupation', { //no le paso el id porque se genera por defecto
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    }
  },
  { 
    timestamps: false, (este seteo sirve para que mis tablas se creen en singular)
    freezeTableName: true,
  });
};

(5°) para poder ver estas tablas en mi base de datos que creé:

tengo que hacer en la terminal integrada sobre mi carpeta 'api' un:

npm i  y  npm start

luego de esto si voy a poder ver las tablas en la db

(6°) CREO LAS RELACIONES en este caso de muchos a muchos.

esto me va a generar una nueva tabla 'character_occuption'

const { Character, Occupation } = sequelize.models;

Character.belongsToMany(Occupation, {through: 'character_occuption'});
Occupation.belongsToMany(Character, {through: 'character_occuption'});

(7°) CREO LAS RUTAS en el archivo index de la carpeta routes

PRIMERO tengo que crear mis funciones controladoras
que me traen todo de la api , todo de la db y las dos concatenadas

lo ideal es hacer un archivo por cada tipo de ruta

instalamos axios: npm i axios    y lo importamos

FRONT

1° Para inicializar nuestro proyecto hacemos en la terminal del escritorio
   npx create-react-app
   Esto nos crea el esqueleto de nuestro proyecto + babel y webpack

2° Instalamos tambien las siguientes dependencias:

   npm i axios react-redux redux
   npm i react-router-dom@5.2.0

   redux: Es una biblioteca de manejo de estados
    
    Store: Es un objeto de javascript
           donde se va a almacenar todo tu estado y es inmutable
           y nos permitira acceder desde cualquier componente

    Action: Es un objeto que le dice a la store que operacion se va a ejecutar

            const myAction = {
                type: 'counter/incremented' (nomre de la accion)
                payload: 20 (dato que queremos darle al store para que se actualice)
            }

            para ejecutarlo utilicamos el metodo "dispatch()"

    Reducer: Es una funcion que espera 2 parametros, state, para saber que informacion
             tiene el store hasta el momento y action, para saber que dato ejecutar.
            
             const initialState = {value: 0}

             function counterReducer(initialState, action){
                 if(action.type === 'counter/incremented'){
                     return{
                         ...state,
                         value: state.value + 1
                     }
                 }
                 return state (este seria el nuevo estado de toda la app)
             }

   react-redux: es una librería que nos ayuda a conectar el store con las propiedades del componente.

   axios: sirve para hacer las llamadas a la API

   react-router-dom: Con esta librearía vamos a obtener un enrutamiento dinámico 
                     gracias a los componentes, en otras palabras tenemos unas rutas que renderizan un componente.

*BrowserRouter

Este componente es el encargado de envolver nuestra aplicación dándonos acceso al API historial de HTML5 (pushState, replaceState y el evento popstate) para mantener su UI sincronizada con la URL.

*Switch

Este componente es el encargado de que solo se renderice el primer hijo Route o Redirect que coincide con la ubicación. Si no usamos este componente, todos los componentes Route o Redirect se van a renderizar mientras cumplan con la condición establecida.

*Route

Con Route podemos definir las rutas de nuestra aplicación, quizás sea el componente más importante de React Router para llegar a comprender todo el manejo de esta librería. Cuando definimos una ruta con Route le indicamos que componente debe renderizar.

Este componente cuanta con algunas propiedades.

_Path: la ruta donde debemos renderizar nuestro componente podemos pasar un string o un array de string.

_Exact: Solo vamos a mostrar nuestro componente cuando la ruta sea exacta. Ej: /home === /home.

_Strict: Solo vamos a mostrar nuestro componente si al final de la ruta tiene un slash. Ej: /home/ === /home/

_Sensitive: Si le pasamos true vamos a tener en cuenta las mayúsculas y las minúsculas de nuestras rutas. Ej: /Home === /Home

_Component: Le pasamos un componente para renderizar solo cuando la ubicación coincide. En este caso el componente se monta y se desmonta no se actualiza.

_Render: Le pasamos una función para montar el componente en línea.

function App() {
  return (
    <div className="App">
      <NavBar/> 
      <Route path='/' exact component={Home}/>
    </div>
  );
}

export default App;

3° Creo dentro de src las carpetas "components" y "redux"

*en components creo una carpeta por cada componente y un archivo index.jsx por c/ubicación

si quiero que sean componentes funcionales colocando "rfce" se me auto-genera

si quiero que sean componentes de clases colocando "rcc" se me auto-genera

*en redux creo las carpetas actions, reducer, store

4° voy al archivo main //index.js 

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
//Si quiero poder navegar por mi aplicacion me tengo que traer BrowserRouter
//Luego envuelvo mi componente app con el componente BrowserRouter
import { BrowserRouter } from 'react-router-dom';
import {Provider} from 'react-redux';
import store from './redux/store';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}> provider ==> es el componente de orden superior proporcionado por React-Redux que le permite asociar Redux a React 
    <BrowserRouter>
    <App />
    </BrowserRouter>
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);

5° voy al archivo //app.js

//Para navegar me tengo que traer el componente Route para decir donde quiero
//mostrar cada cosa
import {Route} from 'react-router-dom';
import './App.css';
import Home from './components/Home';
import NavBar from './components/NavBar';
import Favoritos from './components/Favoritos';
import Personaje from './components/Personaje';
import CreateCharacter from './components/CreateCharacter';

function App() {
  return (
    <div className="App">
      <NavBar/> 
      <Route path='/' exact component={Home}/>
      <Route path='/favorites' component={Favoritos}/>
      <Route path='/character/:id' component={Personaje}/>
      <Route path='/create/character' component={CreateCharacter}/>
    </div>
  );
}

export default App;

6° Me voy al componente NavBar //index.jsx

Hago lo siguiente para no tener que estar escribiendolo en la url

import React from 'react'
import {Link} from 'react-router-dom';

function NavBar() {
  return (
    <ul>
      <li>
      <Link to='/'>Home</Link>
      </li>
      <li>
      <Link to='/favorites'>Favoritos</Link>
      </li>
      <li>
      <Link to='/create/character'>Create a Character</Link>
      </li>
    </ul>
  );
}

export default NavBar;

7° Creo la store

import { createStore, applyMiddleware, compose } from 'redux';
import thunk from 'redux-thunk';
import reducer from '../reducer';

const composeEnhancers =
(typeof window !== 'undefined' &&
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||
    compose;

const store = createStore(reducer,composeEnhancers(applyMiddleware(thunk)));

export default store;

"Redux-thunk te permite escribir creadores de acciones que retornan una función
en vez de un objeto de acción típico. Entonces, el thunk puede ser usado para
retrasar el envío de una acción hasta que se cumpla una línea de código asíncrona."

"Compose: Combina funciones de derecha a izquierda."


ACTIONS:

/*import axios from "axios";
const urlMyApi = "http://localhost:3001";
const {API_KEY} = process.env;
export function getAllDogs() {
    return async function (dispatch) {
        var json = await axios.get(`http://localhost:3001/dogs?api_key=${API_KEY}`, { //axios.get(`${urlMyApi}/dogs`
        });
        return dispatch({//necesario para despachar la accion
            type: "GET_ALL_DOGS",
            payload: json.data
        });
    }
};

export function getTemperaments() {
  return async function (dispatch) {
      var json = await axios.get(`/temperament`); //axios.get(`${urlMyApi}/temperament`)
      return dispatch({
          type: "GET_TEMPERAMENTS",
          payload: json.data,
      });
    }  
};

export function FilterByTemperament(payload) {
    return{
        type: "GET_FILTER_TEMPERAMENTS",
        payload
    }
};

export function getBreed(payload) {//dogs by name
    return async function (dispatch) {//Dispatch que podemos usar gracias a la asincronia provista por el middleware thunk
        try {
            var json = await axios.get(`/dogs?name=${payload}`) //axios.get(`${urlMyApi}/dogs?name=${payload}`)
            return dispatch ({
                type: "GET_BREED",
                payload: json.data
            })
        } catch (error) {
            console.log(error);
        }
    }
};

export function OrderByName(payload) {
    return { 
        type: "ORDER_BY_NAME",
        payload
    }
};

export function OrderByWeight(payload) {
    return { 
        type: "ORDER_BY_WEIGHT",
        payload
    }
};

export function showDogDetails(id) {
    return async function (dispatch) {
        try {
            var json = await axios.get("/dogs/"+id, { //axios.get("http://localhost:3001/dogs/"+id
        });
        return dispatch({
            type: "SHOW_DOG_DETAILS",
            payload: json.data
        });
        } catch (error) {
            console.log(error);
        }
    }
};

export function postDog(payload) {
    return async function () {
        const data = await axios.post("/dog", payload); //axios.post("http://localhost:3001/dog"
        return data;
    }
}*/

REDUCER:

/*// import {
//   GET_ALL_DOGS,
//   GET_TEMPERAMENTS,
//   GET_FILTER_TEMPERAMENTS,
//   GET_BREED,
//   ORDER_BY_NAME,
//   ORDER_BY_WEIGHT,
// } from "../types/index";

const intialState = {
    dogs: [],
    temperaments: [],
    allDogs: [],
    details: [],
  };
  
  const rootReducer = (state = intialState, action) => {
    switch (action.type) {
      case "GET_ALL_DOGS":
        action.payload.forEach(element => {
          if (!element.temperaments[0]) {
            element.temperaments[0] = "no-temperaments" //eliminamos arreglos vacios de temperamentos
          }
        });
        return {
          ...state,
          dogs: action.payload,
          allDogs: action.payload,
        };
      case "GET_TEMPERAMENTS":
        const filteresTemp = action.payload.filter((temp) => temp.name !== ""); //eliminar razas con strings vacios
        return {
          ...state,
          temperaments: filteresTemp,
        };
  
      case "GET_FILTER_TEMPERAMENTS":
        const allDogs = state.allDogs;
        let filteredDogs = [];
        if (action.payload === "Todos") {
          filteredDogs = allDogs;
        } else {
          for (let i = 0; i < allDogs.length; i++) {
            let found = allDogs[i].temperaments.find((t) => t === action.payload);
            if (found) {
              filteredDogs.push(allDogs[i]);
            } //todos los perros en la posicion de ese momento
          }
        }
        return {
          //return funciona correcto
          ...state,
          dogs: filteredDogs,
        };
      case "GET_BREED":
        return {
          ...state,
          dogs: action.payload,
        };
      case "ORDER_BY_NAME":
        const sortedName =
          action.payload === "A-Z"
            ? state.allDogs.sort((a, b) => {
                if (a.name > b.name) {
                  return 1;
                }
                if (b.name > a.name) {
                  return -1;
                }
                return 0;
              })
            : state.allDogs.sort((a, b) => {
                if (a.name > b.name) {
                  return -1;
                }
                if (b.name > a.name) {
                  return 1;
                }
                return 0;
              });
        return {
          ...state,
          dogs: sortedName,
        };
  
      case "ORDER_BY_WEIGHT":
        const sortedWeight =
          action.payload === "min_weight"
            ? state.allDogs.sort((a, b) => {
                if (parseInt(a.weight[1]) > parseInt(b.weight[1])) {
                  return 1;
                }
                if (parseInt(b.weight[1]) > parseInt(a.weight[1])) {
                  return -1;
                }
                return 0;
              })
            : state.allDogs.sort((a, b) => {
                if (parseInt(a.weight[1]) > parseInt(b.weight[1])) {
                  return -1;
                }
                if (parseInt(b.weight[1]) > parseInt(a.weight[1])) {
                  return 1;
                }
                return 0;
              });
        return {
          ...state,
          dogs: sortedWeight,
        };
      case "SHOW_DOG_DETAILS":
        let myDetails = action.payload
        if (!myDetails[0].temperaments[0]) { //agregamos "no-temperaments" a arreglos sin elementos dentro
          myDetails[0].temperaments[0] = "no-temperaments"
        }
        return {
          ...state,
          details: myDetails
        };
      default:
        return state;
    }
  };
  
  export default rootReducer;*/